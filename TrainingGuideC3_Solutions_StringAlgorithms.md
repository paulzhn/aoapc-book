#《算法竞赛入门经典——训练指南》第三章 字符串算法 习题题解

提示：以下题解可以用于任何非盈利用途，但请注明出处，一是尊重作者的劳动，二是让更多的人知道这个题解的存在，大家共同维护 :)

如果你想contribute的话，直接以留言或者email的形式把题解发给我们，或者先写一篇长长的blog，再告知链接 :)

## UVa11488 超级前缀集合(Hyper Prefix Sets) ##

[题目大意]

参见训练指南相应习题部分。

[分析]

(by 陈锋)

将所有输入的字符串插入到一个Tire里面，每个节点维护一个Count属性，表示当前节点插入的次数。记这个节点的深度为d，根节点d = 0。则所有字符串插入完毕之后，d `*` count的最大值即为所求的问题解。

## LA3907(UVa 1399) 谜题(Puzzle) ##

[题目大意]

给出可用的n个大写字母，比如n=4即是(A, B, C, D)；同时给出s个被禁止的字符串，互相之间都不包含。现在需要使用给定的n个字母造出一个最长的字符串。如果因为我们可以造出任意长的字符串或者说是无法造出满足需求的字符串，输出"No"。否则输出造出的字符串。

[分析]

(by 陈锋)

首先，构造出AC自动机。则在此题中，构造目标字符串的过程中，每生成一个字母，相当于在AC自动机中走一步。所有单词结点标记为“禁止”，在AC自动机删除这些禁止节点之后得到一个图。则本题就是在途中从结点0开始计算在的最长路。如果有环的话就可以构造出任意长的字符串，问题无解。然后针对这个DAG使用DP求出每个节点u开始的最长路d[u](u.md)。则从0开始的最长路对应的字符串就是最终答案，构造方法：
```
int u = 0;
string str;
while(dp(u))
{
    for(int j = n-1; j >= 0; --j) {// 从大到小，保证字典序符合题目要求
        int x = ac.ch[u][j];
        if(x && !ac.match[x] && dp(x) + 1 == dp(u)) {
            str.push_back(j + 'A');
            u = x;
            break;
        }
    }
}
```

注意，如果str长度为0，最长路为0，问题也无解。

在图构造好之后，判环的过程，可以使用DFS实现，详见入门经典-P111，拓扑排序的实现。求DAG的最长路实现参考入门经典-P162。

## UVa11855 流行词(Buzzwords) ##

[题目大意]

给出一个字符串S，只包含空格和大写字母。去掉空格之后，针对L = 1, 2, 3...，寻找长度为L的出现次数最多的重复子串，并且输出最多的次数。直到不存在长度为L的重复子串为止。

[分析]

(by 陈锋)

需要注意的是，题意要求是必须是重复子串的出现次数，如果没有重复的子串，需要直接终止当前的案例。

  1. 基于后缀数组的解法 ： 根据SA的定义，观察处理完毕之后的Sa.height`[`1...n`]`，对于特定的L来说，如果出现连续的x个height`[`i`]` >= L，则说明出现了x+1个长度为L的重复子串。则对height数组进行扫描一遍就可以得到所有重复出现的子串的重复次数，并且可以得到L对应的所有重复子串的最大重复次数maxc。如果maxc > 1，输出maxc，否则结束当前案例。
  1. 基于Hash值的Lcp解法 ： 参考《训练指南》3.4.3一节提供的算法，对于特定的L来说，求出所有的长度为L的后缀的hash，并将这些hash放到一个数组中进行排序，然后对排序后的所有hash进行扫描，并且得到所有重复出现的hash的最大重复次数maxc，如果maxc > 1，则输出maxc，否则结束当前案例。