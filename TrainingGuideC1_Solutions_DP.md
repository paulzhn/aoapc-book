#《算法竞赛入门经典——训练指南》第一章DP类习题简要题解

提示：以下题解可以用于任何非盈利用途，但请注明出处，一是尊重作者的劳动，二是让更多的人知道这个题解的存在，大家共同维护 :)

如果你想contribute的话，直接以留言或者email的形式把题解发给我们，或者先写一篇长长的blog，再告知链接 :)

# 动态规划（DP） #

## UVA10051 方块塔(Tower of Cubes) ##

[题目大意]

给出N个涂色的方块，每个重量都不一样。方块的每个面都涂一种颜色。现在你根据如下的规则用这些方块堆一个塔：
  1. 不允许用一个重的方块放在轻的上面。
  1. 每个方块(除了最底下那个放在地上的)的底面必须和放在它下面的方块的顶面的颜色一样。
  1. 造出来的塔要尽量最高。

[分析]

(by 陈锋)

第i个盒子为顶，第s面朝上，对应的最大高度记为D[i,s]，则有：D(i,s) = 1 + max(0, D(j, k)), j > i，且i.color`[``[`op`[`s`]``]``]` = j.color`[`k`]`.

## UVA10100 最长匹配(Longest Match) ##

[题目大意]

给定两个包含单词的字符串，求出最长的公共子单词序列。

[分析]

(by 陈锋)

把两个字符串看成单词序列，然后应用LCS的算法就OK了。

## UVA10130 超市 (SuperSale) ##

[题目大意]

在一个超市里面，每种货物每人限买一个。现在有个家庭，每人可以尽量多带物品。给出一系列物品的价格和重量，以及每个人能带的最大重量。那么求这个家庭最多能从超市买多少价值的东西。

[分析]

(by 陈锋)

针对家庭的每个成员应用最简单的01背包求最大值，最后把全家的最大值加起来就可以了。

## UVA10243 火警(Fire! Fire!! Fire!!!) ##

[题目大意]

有个博物馆，由很多画廊组成，这些画廊以通道链接，这样每个画廊都有i条直路可以达到其它画廊而不需要两次路过任何中间的画廊。现在需要在博物馆里面安装紧急出口来应付火灾。

现在需要节省安装成本，决定不需要在每个画廊上安装紧急出口。但是要符合如下条件：如果一个画廊没装紧急出口，那么它的相邻画廊里面必须有一个已经装过；并且对于任意一个通道来说，其相连的两个画廊必须有一个装过紧急出口。现在需要确定如何安装紧急出口。

[分析]

(by 陈锋)
```
DP[i][1] 表示i 选上了的话，以i为根的子树上最少需要选多少个
DP[i][0] 表示i 不选的话，以i为根的子树上最少需要选多少个
状态方程
dp[i][1] = Σ（j ∈ i的子节点） min(dp[j][1],dp[j][0])
dp[i][0] = Σ（j ∈ i的子节点） dp[j][1]
```
## UVA10306 电子货币(e-Coins) ##

[题目大意]

现在有一种新的电子货币，除了传统意义上的面值之外，还有一个电子面值。为了方便比较一些货币的价值，引入电子模量的概念。其计算公式就是 sqrt(X2 + Y2)，X和Y分别表示相应的传统面值和电子面值的和。比如现在有一些钱，按照传统面值，它们的和是3美元，按照电子面值，它们的和就是4美元，所以可求得电子模量就是5美元。需要注意的是，你需要首先分别计算传统面值和电子面值的和，然后才能计算电子模量。
现在有一个问题，给出一个所求的电子模量以及一个可用的不同类型的电子货币列表，需要计算出需要最少多少的电子货币才能得到这个电子模量。对于每种电子货币，可以任意用多少个，来达到对应的电子模量。

[分析]

(by 陈锋)

定义D(x,y)为，可以组合出(x,y)的电子货币组合的最小个数，那么D(x,y) = min{dp[x-Xk,y-Yk]} + 1}，其中1<=k<=n。(Xk, Yk)就是第k个货币的两个面值。

## UVA10400 游戏展的数学(Game Show Math) ##

[题目大意]

现在有个正数序列和一个目标数字，需要用这个序列和+,-,`*`,/运算符构造一个数学表达式。序列中的每个数字只能用一次，但是每个操作符可以用0到任意次。表达式从左到右求值，忽略运算符优先级，然后算出目标数字。有可能没有任何表达式能够计算出目标数字。也有可能有多种表达式能够计算出目标数字。
表达式的构造过程有三个限制：
> 在表达式中数字出现的顺序必须是跟输入中的顺序一样。
> 因为目标数字都是正整数，只有在运算的余数为0 的时候才能使用除法。
> 要应用一个运算符之前必须确定运算的结果在(-32000..+32000)的范围内。

[分析]

(by 陈锋)

状态包括当前还需要确定的操作符个数i，以及当前目标运算结果t ，从右到左递归，注意按照题目中限制的运算条件剪枝。这样就写成记忆化的DFS。

## UVA10404 Bachet游戏(Bachet's Game) ##

[题目大意]

现在有个游戏，桌上刚开始有n个石头，两个玩家Stan和Ollie，轮流出招。Stan总是先开始，谁拿走最后一个石头，谁就赢。每次能移除的石头数量必须是一个长度为m的数集合中的其中一个。这m个数中肯定包含1，所以游戏不可能走不下去。

[分析]

(by 陈锋)

1.	DP(i)表示在还剩下i个石头的时候，轮到的玩家是否能必须赢。
2.	初始的时候，当i 属于M（m个数的集合），DP(i) = true。因为他可以一次就抓完了。
3.	之后，对于其它的i，if DP(i - k) == false for any k in M。则DP(i) == true。因为他至少有一招让对方输。
4.	算法复杂度 O(n\*m)。

## UVA10534 波浪序列(Wavio Sequence) ##

[题目大意]

波浪序列是一个整数序列，同时满足以下属性：
1.	长度为奇数 L = 2\*n + 1
2.	前n+1个数严格递增
3.	后n+1个数严格递减
4.	相邻的数都不相同
比如1,2,3,4,5,4,3,2,0就是长度为9的波浪序列。但是1,2,3,4,5,4,3,2,2不是。现在给出一个整数序列。要找出其中最长的波浪子序列的长度。比如，当给定序列：
1 2 3 2 1 2 3 4 3 2 1 5 4 1 2 3 2 2 1。
最长的波浪子序列就是 1 2 3 4 5 4 3 2 1，所以答案就是9。

[分析]

(by 陈锋)

每一个位置i，都有一个最长严格递增序列以i为结束，和一个严格递减序列以i开始。
算出每个i的这两个序列的这两个状态。而这两个指标，都可以用O(n^2)的算法填表填出来。
这两个状态的递归公式是显然的。一个从左边开始填，一个从右边开始填。
然后就可以把这两个状态放一起算出来以其为中心的波浪序列的长度。算法复杂度是O(2\*n^2 + n).

## UVA10564 沙漏里的路径(Paths through the Hourglass) ##

[题目大意]

在如图所示的沙漏里面标出了一个路径。一个路径总是从第一行开始，到最后一行结束。在路径里面的每个格子(除了第一个)必须是在上一层中路径经过格子的左面或者右面。一个路径的值就是其经过的所有格子的值的总和。
路径的描述如下，首先是其在第一行的起始点的位置，跟着是一个字符串表明每一步的方向，指出每一步的走向。比如图中的路径可以描述为2 RRRLLRRRLR。
给出沙漏里面所有格子的值，计算出所有值等于S的路径的个数。如果至少有一个路径存在，打印出最小起始点的路径。如果有多个路径存在，选择按照字典序最小的。

[分析]

(by 陈锋)

按照DFS的思路写。在DFS的入口处根据当前的输入状态(row, col, sum)，做记忆化。

## UVA 10651 石子接龙(Pebble Solitaire) ##

[题目大意]

石子接龙是一种游戏。开始是一个木板，有12个小洞，它们在同一条直线上，有些小洞里面有石子。游戏的目标是尽量多的取出其中的石子。要通过特定规则的移动才能取出石子。只要当满足以下条件的时候才能移动：有3个相邻的在一条直线上的小洞，标记为A,B,C，B在中间，A是空的，B,C中都有石子。一次移动包含2个动作，把石子从C移到A，并且把B中的石子移除。可以连续的移动，知道无法继续下去为止。
现在你需要找到一系列的移动动作使在木板上剩下的石子最少。

[分析]

(by 陈锋)

把12个点的状态映射成整数(最大的也就2^12 – 1 = 4095个点)，然后就是DFS加上一个状态数组的记忆化搜索。

## UVA 10688 - 可怜的巨人(The Poor Giant) ##

[题目大意]

桌上有n个苹果，第i个苹果重量是k+i(1<=i<=n)。仅仅有一个苹果是最甜的，比它轻有些苦，比它重的更酸。这个巨人想知道哪个是最甜的，唯一能做的就是吃苹果。他讨厌苦的或者酸的苹果，该怎么办？可怜的巨人应该准备好吃下一些坏苹果，才能知道到底哪个是甜的。现在要计算出所有情况中最小的总重量。

[分析]

(by 陈锋)

子问题：给一个连续整数区间：(i,..., i+x) x >= 0，和其中的某个数j。求出按照题目的逻辑进行二分查找到这个j所路过的数的总和。
D(i,x,j)

对于n, k;
```
minAns = INFINITE
for start := k+1 to k+n // 枚举不同的搜索起点
	ans = 0
	for j := k+1 to k+n // 枚举不同的目标j
		ans += start
		if j > start
			ans += D(start + 1, n - start, j)
		else if j < start
			ans += D(1, start - 1, j)
	
	minAns = min(ans, minAns)
```
最后minAns就是答案

## UVA 10700 - 骆驼交易(Camel trading) ##

[题目大意]

对于一个表达式比如1+2\*3\*4+5，在其中不同的位置插入不同的括号，会得到不同的结果。现在要求出可能的最大或者最小结果。

[分析]

(by 陈锋)

我们定义运算A # B。# 是+或者`*`。因为每次运算都是二值运算，那么这个题就可以套用入门经典中例题9-6(最优矩阵相乘)里面的算法状态转移方程了：f(i, j) = max(f(i,k) # f(k,j)) 最大值可能是20^12 = 4096000000000000，得用int64来存放。

## UVA 10702 旅行商人(Travelling Salesman) ##

[题目大意]

现在有个旅行商人，到一个城市就卖掉所有的东西然后买一些新东西。接着就旅行到另外一个城市，再做买卖。

现在需要计算出在最优化的旅行过程中总共能挣多少钱。在这个旅行过程中，他可以多次到同一个城市，并且他必须在某些特定的城市中结束旅行。并且他的旅行还有一个起点，还有半路想要路过做买卖的城市的个数。

[分析]

(by 陈锋)

令cur当前所在城市，e为还剩多少个城市没走。定义f(cur, e) 为对应cur, e的最大利润，则状态转移方程为 f(cur, e) = max{Profit`[`cur]`[`next] + f(next, e-1), where Profit`[`cur]`[`next] > 0}，当e等于1的时候，下个城市的选择必须从给定的E集合中选，选完之后递归终止。则题目所求的答案为f(S, T)。
算法复杂度为O(C\*T\*S)

## UVA10817 校长的烦恼(Headmaster's Headache) ##

[题目大意]

学校的校长要给一些学科新招一些老师。有很多老师申请职位。这些老师都能教一个或多个学科。校长希望从其中挑出一些老师，要保证每个学科都有至少两个老师教，并且总体代价最低。

[分析]

(by 陈锋)
```

关键是状态可以表述为:
{
    还没有判断过的求职者个数i,
    各个学科还需要的老师个数ST
}

假设D(i) 等于规模为i的时候的解。
D(i+1) =
{	
	// 记忆化的逻辑省略
	// i = 0时候结束递归，逻辑显然。
    // 把i+1选上, ST做相应处理
    ans = (C[i] + D(i))
    // 去掉i + 1, ST做相应处理
	if D(i) > 0 ans = min(ans, D(i))	
	return ans
};
```
最后的答案就是D(n)了。时间复杂度为O(n **3^s)。**

## UVA11081 字符串(Strings) ##

[题目大意]

给出3个小写的字符串，现在你要计算出有多少种方式，可以从前两个字符串的子串构造出第三个串。
从一个字符串如果删除0或者多个字符，我们可以得到其子串。比如“a”, “b”, “c”, “ab”, “ac”, “bc” 和“abc” 都是 “abc”的子串。子串可以为空。
假设现在有两个子串"abc"和"de"。通过对它们的组合，你可以得到下面的字符串“abcde”, “abdce”, “abdec”, “adbce”, “adbec”, “adebc”, “dabce”, “dabec”, “daebc” 以及“deabc”。


[分析]

(by 陈锋)

前两个字符串，命名为A和B。对于第三个字符串C中的每个字符，有一个决策的过程，每个字符从A和B里面选一个字符跟当前相等的，选了之后(这里是决策过程)，被选的那个字符串剩下的长度就减去一些。C的长度也减一。
这样问题的状态可以表达为
｛
> i = A剩下的长度
> j = B剩下的长度
> c = C中未决策的字符串长度
｝
算法复杂度就是O(N^3)，N是三个字符串的最大长度。写成记忆化搜索就可以了。

## UVA11502 多级火箭(Rocket Stages) ##

[题目大意]

火箭一般都做成多级来提高效率。当其中一级的燃料烧完之后，这一级就被丢掉，减轻火箭剩余部分的重量。第一级必须有一个足够强的引擎来推动整个火箭，后面各级的引擎可以稍小一些。
在这个问题中，需要确定出应该把那些级放在一起使得所有燃料烧完之后的向上加速度最大。
对每个级，给出如下参数：
1.	不带燃料时的质量S，以千克为单位。
2.	携带的燃料的重量L，以千克为单位
3.	所安装引擎的推力T，以牛为单位
4.	每秒的燃料消耗，以千克/秒为单位
假设火箭在飞行的过程中一直是垂直向上的。两种力作用于这个火箭：引擎的力(T牛，方向向上)，以及重力(9.8\*M牛向下，M是火箭的重量，包括燃料。火箭的加速度就是F/M (m/s2)，其中F就是作用于火箭的合力。当一级烧完的时候，它就立刻被抛弃并且下一级开始燃烧。火箭的最终速度就是净加速度对时间的积分。
由于安全限制，在燃料烧完之前，不允许出现向下的净加速度。同样由于安全限制，火箭的总重量不能超过10000千克。
这个火箭至少得有1级。

[分析]

(by 陈锋)
```
state =
{
    a // 当前加速度
    v // 当前的速度
    i // 剩下还有几节火箭没有决策
    t // 当前已经选择好的级的质量和
}
```
决策的时候从火箭顶端开始往下，挨个决策。

最终的速度可以对应到坐标轴上方连续一系列的梯形(三角形是其中的特例)的面积总和。需要注意的是，对于一个特定的火箭级，不管它选择与否，都会影响到所有其它梯形的高度。另外，就算DP可以计算的出来，记忆时候状态也要注意精度问题。